name: Deploy My Docker Application
on:
  workflow_dispatch: null
permissions:
  id-token: write
  contents: write
jobs:
  Get-Tag-Version:
    runs-on: ubuntu-latest
    outputs:
      version: '${{ steps.get_version.outputs.version }}'
    steps:
      - name: Checkout source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Get latest semantic version
        id: get_version
        run: |
          # Get the latest tag (e.g. v1.2.3)
          LATEST_TAG=$(git tag --sort=-v:refname | grep '^v' | head -n 1)
          echo "Latest tag: $LATEST_TAG"

          if [ -z "$LATEST_TAG" ]; then
            VERSION="1.0.0"
          else
            IFS='.' read -r MAJOR MINOR PATCH <<< "${LATEST_TAG#v}"
            MINOR=$((MINOR + 1))
            VERSION="${MAJOR}.${MINOR}.${PATCH}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

  Build-CI:
    needs: Get-Tag-Version
    runs-on: ubuntu-latest
    steps:
      - name: Checkout source
        uses: actions/checkout@v4
      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '8'
      - name: Build with Maven
        run: sh mvnw clean install
      - name: Upload JAR artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-jar
          path: target/*.jar
      - name: Tag the commit
        if: github.ref == 'refs/heads/main'  # Only tag on main
        run: |
          VERSION=${{ needs.Get-Tag-Version.outputs.version }}
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git tag "v$VERSION"
          git push origin "v$VERSION"

  Build-Image-Publish-ECR:
    needs:
    - Get-Tag-Version
    - Build-CI
    runs-on: ubuntu-latest
    outputs:
        image_url: ${{ steps.push_image.outputs.image_url }}
    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Download jar artifact
        uses: actions/download-artifact@v4
        with:
          name: app-jar

      - name: Copy JAR to repo root
        run: |
          # The jar is downloaded here - find and rename to springbootapp.jar
          find . -type f -name "*.jar" -not -name "*sources.jar" -exec cp {} springbootapp.jar \;

      - name: AWS configure credentials
        uses: aws-actions/configure-aws-credentials@v4.1.0
        with:
          role-to-assume: '${{ secrets.IAM_ROLE }}'
          aws-region: us-east-1

      - name: Create ECR repository (if not exists)
        run: |
          SERVICE_NAME="springbootapp"
          if aws ecr describe-repositories --repository-names "$SERVICE_NAME" > /dev/null 2>&1; then
            echo "ECR repository $SERVICE_NAME already exists, skipping creation."
          else
            echo "Creating ECR repository $SERVICE_NAME..."
            aws ecr create-repository --repository-name "$SERVICE_NAME" --region us-east-1
          fi

      - name: Log in to Amazon ECR
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          SERVICE_NAME="springbootapp"
          ECR_REPO_URL="${AWS_ACCOUNT_ID}.dkr.ecr.us-east-1.amazonaws.com/${SERVICE_NAME}"
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin "$ECR_REPO_URL"

      - name: Build Docker image
        run: |
          SERVICE_NAME="springbootapp"
          VERSION="v${{ needs.Get-Tag-Version.outputs.version }}"
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REPO_URL="${AWS_ACCOUNT_ID}.dkr.ecr.us-east-1.amazonaws.com/${SERVICE_NAME}"

          docker build -t $SERVICE_NAME:$VERSION .
          docker tag $SERVICE_NAME:$VERSION $ECR_REPO_URL:$VERSION

      - name: Push to Amazon ECR
        id: push_image
        run: |
          SERVICE_NAME="springbootapp"
          VERSION="v${{ needs.Get-Tag-Version.outputs.version }}"
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REPO_URL="${AWS_ACCOUNT_ID}.dkr.ecr.us-east-1.amazonaws.com/${SERVICE_NAME}"
          IMAGE_URL="${ECR_REPO_URL}:${VERSION}"
          docker push $IMAGE_URL
          echo "IMAGE_URL=$IMAGE_URL" >> $GITHUB_ENV  # For debugging
          echo "image_url=$IMAGE_URL" >> $GITHUB_OUTPUT  # Needed for output

  Deploy-to-ECS:
    needs:
      - Get-Tag-Version
      - Build-CI
      - Build-Image-Publish-ECR
    runs-on: ubuntu-latest
    steps:
      - name: Checkout source
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 1

      - name: AWS configure credentials
        uses: aws-actions/configure-aws-credentials@v4.1.0
        with:
          role-to-assume: ${{ secrets.IAM_ROLE }}
          aws-region: us-east-1

      - name: Debug IMAGE_URL
        run: |
          IMAGE_URL="${{ needs.Build-Image-Publish-ECR.outputs.image_url }}"
          echo "IMAGE_URL: $IMAGE_URL"

      - name: Replace springboot-app.json placeholders
        run: |
          IMAGE_URL="${{ needs.Build-Image-Publish-ECR.outputs.image_url }}"
          echo "Replacing placeholder in springboot-app.json with IMAGE_URL: $IMAGE_URL"
          cat springboot-app.json  # Debugging to verify before
          # Ensure proper escaping of special characters in the sed command
          sed -i "s|\${docker_image_url}|$IMAGE_URL|g" springboot-app.json
          cat springboot-app.json  # Debugging to verify replacement
         # aws ecs create-service   --cluster Production-ECS-Cluster   --service-name springbootapp   --task-definition springbootapp   --desired-count 1   --launch-type FARGATE   --network-configuration "awsvpcConfiguration={subnets=[subnet-0532b3e0932821801,subnet-099a0fd72e9ab05c7],securityGroups=[sg-0963d87b80d145533],assignPublicIp=ENABLED}"

      - name: Deploy to Amazon ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: springboot-app.json
          service: springbootapp
          cluster: Production-Fargate-Cluster
          wait-for-service-stability: true
